import type { LeanEvent } from '../event'

export interface CacheConditions {
   modifiedTime?: string | Date
   maxAge?: number
   etag?: string
   cacheControls?: string[]
}

/**
 * Check request caching headers (`If-Modified-Since`) and add caching headers (Last-Modified, Cache-Control)
 * Note: `public` cache control will be added by default
 * @returns `true` when cache headers are matching. When `true` is returned, no reponse should be sent anymore
 */
export function handleCacheHeaders(
   event: LeanEvent,
   opts: CacheConditions,
): boolean {
   const cacheControls = ['public', ...(opts.cacheControls || [])]
   let cacheMatched = false

   if (opts.maxAge !== undefined)
      cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`)

   if (opts.modifiedTime) {
      const modifiedTime = new Date(opts.modifiedTime)
      const ifModifiedSince = event.node.req.headers['if-modified-since']
      event.node.res.setHeader('last-modified', modifiedTime.toUTCString())
      if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime)
         cacheMatched = true
   }

   if (opts.etag) {
      event.node.res.setHeader('etag', opts.etag)
      const ifNonMatch = event.node.req.headers['if-none-match']
      if (ifNonMatch === opts.etag)
         cacheMatched = true
   }

   event.node.res.setHeader('cache-control', cacheControls.join(', '))

   if (cacheMatched) {
      event.node.res.statusCode = 304
      event.node.res.end()
      return true
   }

   return false
}
